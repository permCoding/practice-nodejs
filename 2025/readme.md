## Проектно-технологическая практика 

> ОЧНАЯ ФОРМА ОБУЧЕНИЯ - задание на практику  
> выполнять можно на любом языке программирования (C#, Java, JavaScript, Python, ...)  
> в качестве реляционной базы данных можно использовать любую на ваш выбор (SQLite, MySQL, PosgreSQL, SQL Server, ...)  
> ведёт практику - Беляков Андрей Юрьевич  

### Тема практики: Исследование способов повышения эффективности запросов к реляционной базе данных

Требуется проанализировать и сравнить ресурсы (времени и памяти) в зависимости от организации хранения данных (без индексов, с индексами).  

**В первом разделе Отчёта**  

- опишите различия, особенности применения и лицензирование современных систем управления реляционными базами данных (выберите для анализа 5 штук, например такие - SQLite, MySQL, MariaDB, PosgreSQL, SQL Server).  

**Во втором разделе Отчёта**  

Для оценки производительности запросов и затрат памяти будет использоваться таблица с данными рейтинга абитуриентов при поступлении в вуз. Таблицу нужно будет сгенерировать, сохранить в файл csv и перенести в базу данных, а в базе данных провести раз испытаний.  
**Разработайте функционал:**  

1) функция (метод класса) для генерации Фамилии (кириллицей), первая буква заглавная (прописная), остальные маленькие (строчные), длина Фамилии выбирается случайным образом (от 3-х до 12-ти символов), на первую позицию не стаить неуместные символы (типа Ь, Ъ);  
2) функция (метод) для случайного выбора имени из списка заранее подготовленных имён (Михаил, Олег, Яна, Мирослава, ...), сделайте список длиной в 10 имен;  
   - важно для сравнения производительности запросов и затрат памяти на индексацию, что Фамилии будут совсем разные, а имена часто повторяющиеся  ;
   - в этой работе не будет разделения имён (фамилий) по полу (для упрощения реализации);  
3) функцию (метод) генерации значения рейтинга (целые числа) в диапазоне [150; 250];  
   - rating (это рейтинг абитуриентов при поступлении)  
4) функцию (метод) генерации записей для таблицы (на основе функций 1, 2 и 3) с полями - id, firstName, lastName, rating  
   - сохранить таблицу в формате csv-файла - для контроля получаемых записей;  
5) написать функцию (метод) переноса записей из csv-файла (таблица из п.4) в реляционную базу данных (база данных на ваш выбор, перед испытаниями она пустая, данные туда попадают в результате работы функций вашей программы - читаете из csv файла и записываете в базу данных SQL запросом INSERT);  

---  

6) написать функцию (метод) **удаления** (не очистки, а именно удаления) таблицы из базы данных;  

---  

7) написать функцию (метод) **добавления индекса** по полю Фамилия (lastName);  
8) провести **сравнение затрат памяти** (без индексации по полю Фамилия и с индексацией, для количества записей (100_000, 400_000, 700_000) или другое количество (несколько штук) на ваш выбор, которое позволит провести адекватное сравнение);  
9) удалить таблицу (написанным ранее методом) и снова добавить из csv-файла;  

---  

10) написать функцию (метод) **добавления индекса** по полю Имя (firstName);  
11) провести **сравнение затрат памяти** (без индексации по полю Имя и с индексацией, для количества записей (100_000, 400_000, 700_000) или другое количество (несколько штук) на ваш выбор, которое позволит провести адекватное сравнение);  
12) удалить таблицу (написанным ранее методом) и снова добавить из csv-файла;  

---  

10) написать функцию (метод) **добавления индекса** по полю Рейтинг (rating);  
11) провести **сравнение затрат памяти** (без индексации по полю Имя и с индексацией, для количества записей (100_000, 400_000, 700_000) или другое количество (несколько штук) на ваш выбор, которое позволит провести адекватное сравнение);  
12) удалить таблицу (написанным ранее методом) и снова добавить из csv-файла;  

10) провести **сравнение времени выполнения** запроса SELECT (формат выборки можете совтавить сами, например - выбрать все Фамилия, Имя, которые имеют рейтинг не ниже ):  
   - в зависимости от количества записей,  
   - в зависимости от наличия (отсутствия) индексации  
   - в зависимости от индексации какого именно поля (поле с очень разнообразными элементами (Фамилия) или с ограниченным разнообразием (Имя))  

А) опишите программые реализации функций (методов) с примерами кода,  
Б) проведите эксперименты и соберите данные,  
В) представьте их в виде таблиц (сравнение по количеству записей, по затратам памяти, по времени выполнения запроса SELECT в зависимости от вида поля <Фамилия> или <Имя> (первое - с большим разнообразием данных, второе - с малым разнообразием)) и в виде графиков (можно сделать в Excel или непосредственно вашей программой).  
   - таблицы и графики на ваш выбор - они далжны адекватно демонстрировать влияние (отсутствие влияния) на затраты памяти, на время исполнения, в зависимости от количества записей, от наличия (отсутствия) индексации (в зависимости от многообразия элементов, хранимых в поле)   

---  

**После выполнения практики:**  
- оформить отчёт согласно содержания и по формату (см. Шаблон-отчёта)  
- преподавателю выслать электронную версию для проверки в портале pgatu  
- дождаться ответа, если всё нормально, то распечатать и бумажную версию Отчёта принести в 306 ауд.  

---  

**Примерное содержание Отчёта:**  

```txt
Введение

1. Анализ алгоритмов сортировки <сравнение по количеству операций> 
  1.1 Алгоритмы сортировки со сложностью n**2
    <например, Сортировка пузырьковая, Сортировка выбором, Сортировка вставкой>
	<на ваш выбор две сортировки опишите словами - в чём суть и почему такая ассимптотика сложности>
  1.2 Алгоритмы сортировки со сложностью n*log(n)
    <например, Сортировка слиянием, Быстрая сортировка, Сортировка кучей>
    <на ваш выбор две сортировки опишите словами - в чём суть и почему такая ассимптотика сложности>

2. Разработка и исследование эффективности разработанных программ
  2.1 Разработка программ сортировки
    <описать код программ, особенности реализации>
  2.2 Получение табличных данных и построение графиков функций 
	<сгенерировать входные массивы для сортировки, например, размером от 2_000 до 20_000 с шагом в 2_000>
	<получить данные роста времени исполнения от кол-ва элементов и свести в одну таблицу для наглядности>
	<построить зависимости роста времени исполнения от кол-ва элементов - линии всех сортировок на одном графике>

Заключение <сделать выводы по алгоритмам - ассимптотика сложности, время исполнения, расходуемая память>

Список источников <примерно 5-7 источников>

Приложение А. <тут разместить тексты всех программ, шрифт моноширный от 10 до 12 пт>
```
